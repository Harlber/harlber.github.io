<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Keep learning</title>
    <link>https://harlber.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 26 Sep 2017 02:22:10 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Java的Reference（引用）</title>
      <link>https://harlber.github.io/2017/09/25/Java-Reference/</link>
      <guid>https://harlber.github.io/2017/09/25/Java-Reference/</guid>
      <pubDate>Mon, 25 Sep 2017 10:58:41 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;常见的面试中会有这么一道题，“谈谈强引用、 软引用、 弱引用、虚引用”。&lt;/p&gt;
&lt;p&gt;A：强引用，通过new出来的都是强引用&lt;br&gt;Q：那弱引用呢？&lt;br&gt;A：通过WeakReference构造出的，不再有强引用…&lt;br&gt;Q：那软引用呢，这些引用间的区别是什么？&lt;br&gt;A
        
      
      </description>
      
      <content:encoded><![CDATA[<p>常见的面试中会有这么一道题，“谈谈强引用、 软引用、 弱引用、虚引用”。</p><p>A：强引用，通过new出来的都是强引用<br>Q：那弱引用呢？<br>A：通过WeakReference构造出的，不再有强引用…<br>Q：那软引用呢，这些引用间的区别是什么？<br>A：…</p><p>面到这个阶段这就比较尴尬了。为了避免类似的尴尬，特地花了点时间去整理这些引用，以便下次面试的时候就这个问题能和面试官谈笑风生。</p><p>首先可以在oracle的文档中找到相应的api说明<br>java.lang.ref<br>Class <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ref/Reference.html" target="_blank" rel="external">Reference<t></t></a></p><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html" target="_blank" rel="external">java.lang.Object</a><br>java.lang.ref.Reference<t></t></p><p>Direct Known Subclasses:<br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ref/PhantomReference.html" target="_blank" rel="external">PhantomReference</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ref/SoftReference.html" target="_blank" rel="external">SoftReference</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ref/WeakReference.html" target="_blank" rel="external">WeakReference</a></p><p>Abstract base class for reference objects. This class defines the operations common to all reference objects. Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly.<br>Since:<br>1.2</p><p>事实上在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK 1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p><p><a href="">Strong Reference</a>:<br>强引用是默认实现的引用。垃圾回收器不会回收具有强引用的对象，除非没有任何对象指向它时才会在一次GC 执行后被回收。<code>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题</code>。<br>至此，也许犀利的你发现了这个现象：java中的Reference的子类中并没有一个叫 <strong>StrongReference</strong>的，在文章中写的也是<strong>Strong Reference</strong> 。stackoverflow上也有类似的讨论，<a href="http://stackoverflow.com/questions/15651896/why-is-there-no-strongreference-object" target="_blank" rel="external">点击查看</a>。</p><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ref/SoftReference.html" target="_blank" rel="external">SoftReference</a>：</p><p><code>Soft reference objects, which are cleared at the discretion of the garbage collector in response to memory demand. Soft references are most often used to implement memory-sensitive caches.</code>Suppose that the garbage collector determines at a certain point in time that an object is <a href="">softly reachable</a>. At that time it may choose to clear atomically all soft references to that object and all soft references to any other softly-reachable objects from which that object is reachable through a chain of strong references. At the same time or at some later time it will enqueue those newly-cleared soft references that are registered with reference queues.<br><code>All soft references to softly-reachable objects are guaranteed to have been cleared before the virtual machine throws an OutOfMemoryError</code>. Otherwise no constraints are placed upon the time at which a soft reference will be cleared or the order in which a set of such references to different objects will be cleared. Virtual machine implementations are, however, encouraged to bias against clearing recently-created or recently-used soft references.<br><code>Direct instances of this class may be used to implement simple caches; this class or derived subclasses may also be used in larger data structures to implement more sophisticated caches.</code> <code>As long as the referent of a soft reference is strongly reachable, that is, is actually in use, the soft reference will not be cleared.</code>Thus a sophisticated cache can, for example, prevent its most recently used entries from being discarded by keeping strong referents to those entries, leaving the remaining entries to be discarded at the discretion of the garbage collector.</p><p>请留意文档中标注的片段</p><ul><li><p>软引用对象时刻响应着内存状态<br><a href="">注意</a>  <code>这里并未明说内存不足时将回收软引用对象，内存充裕时则不会回收，待会儿的测试中就能应证这一点</code>。</p></li><li><p>软引用常用于实现高速缓存。<br>这里的缓存指的是高速内存缓存（区别于<a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="external">DiskLruCache</a>）。</p></li><li><p>所有引用了<code>软可及（softly-reachable）</code>的对象将在JVM抛出<code>OutOfMemoryError</code>异常前完成清除，回收工作。<br>由此可见<br>1.以SoftReference实现内存缓存是可靠的。<br>2.软引用对象存在多种状态：<code>软可及（softly-reachable）</code>只是其中一种状态。</p></li><li><p>SoftReference可被用来实现简单的高速缓存;SoftReference类或派生子类也可用于较大的数据结构中实现更复杂的高速缓存。</p></li><li>只要软引用对象是<code>强可及（strongly reachable）</code> 在实际应用中软引用将不会被清除。</li></ul><p>至此，我们可以通过一个简单的Test来验证。下文是一个通过的测试案例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">softReference</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//测试环境，内存充足</span></div><div class="line">    Object referent = <span class="keyword">new</span> Object();</div><div class="line">    SoftReference&lt;Object&gt; softRerference = <span class="keyword">new</span> SoftReference&lt;Object&gt;(referent);</div><div class="line">    assertSame(referent, softRerference.get());<span class="comment">//referent '强可及'</span></div><div class="line">    System.gc(); </div><div class="line">    assertNotNull(softRerference.get());</div><div class="line">    assertNotNull(referent); </div><div class="line">    referent = <span class="keyword">null</span>;<span class="comment">//referent '软可及' </span></div><div class="line">    System.gc();</div><div class="line">    assertNotNull(softRerference.get()); <span class="comment">//referent '软可及'|内存充足，不会被被回收</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ref/WeakReference.html" target="_blank" rel="external">WeakReference</a>：</p><p>Weak reference objects, which do not prevent their referents from being made finalizable, finalized, and then reclaimed. <code>Weak references are most often used to implement canonicalizing mappings</code>.<strong>Suppose that the garbage collector determines at a certain point in time that an object is <a href="">weakly reachable</a>. At that time it will atomically clear all weak references to that object and all weak references to any other weakly-reachable objects from which that object is reachable through a chain of strong and soft references.</strong> At the same time it will declare all of the formerly weakly-reachable objects to be finalizable. At the same time or at some later time it will enqueue those newly-cleared weak references that are registered with reference queues.</p><ul><li>不论内存是否充裕，弱引用对象都将被回收</li><li>弱引用不会阻扰引用对象进行finalizable，finalized还是reclaimed</li><li>弱引用常用于实现<code>canonicalizing mappings</code>。<br>什么是canonicalizing mappings？在此引用一篇文章的解释。原文链接：<a href="http://c2.com/cgi/wiki?CanonicalizedMapping" target="_blank" rel="external">http://c2.com/cgi/wiki?CanonicalizedMapping</a></li></ul><p><code>A &quot;canonicalized&quot; mapping is where you keep one instance of the object in question in memory and all others look up that particular instance via pointers or somesuch mechanism. This is where weaks references can help.The short answer is that Weak Reference objects can be used to create pointers to objects in your system while still allowing those objects to be reclaimed by the garbage-collector once they pass out of scope.</code><br>通俗的说，弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。一个经典的弱引用的使用场景(请自行查阅<a href="">WeakHashMap</a>源码)：哈希表的接口允许使用任何Java对象作为键来使用。当一个键值对被放入到哈希表中之后，哈希表对象本身就有了对这些键和值对象的引用。如果这种引用是强引用的话，那么只要哈希表对象本身还存活，其中所包含的键和值对象是不会被回收的。如果某个存活时间很长的哈希表中包含的键值对很多，最终就有可能消耗掉JVM中全部的内存。</p><p>同样的我们测试一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakReference</span><span class="params">()</span> </span>&#123;</div><div class="line">    Object referent = <span class="keyword">new</span> Object();</div><div class="line">    WeakReference&lt;Object&gt; weakRerference = <span class="keyword">new</span> WeakReference&lt;Object&gt;(referent);     </div><div class="line">    assertSame(referent, weakRerference.get());<span class="comment">//referent '强可及'</span></div><div class="line">    System.gc();</div><div class="line">    assertNotNull(weakRerference.get());</div><div class="line">    assertNotNull(referent);<span class="comment">//referent '强可及' 不会被回收</span></div><div class="line">    referent = <span class="keyword">null</span>;<span class="comment">//取消强引用，referent '弱可及' </span></div><div class="line">    System.gc();</div><div class="line">    assertNull(weakRerference.get()); <span class="comment">//referent '弱可及'将被回收，此时内存充裕</span></div><div class="line">    referent = <span class="keyword">null</span>;</div><div class="line">    System.gc(); </div><div class="line">    assertNull(weakRerference.get()); <span class="comment">//referent `不可及`</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>‘强可及’，’软可及’ ，’弱可及’ ，’不可及’这些引用状态简直看的人一脸懵逼呀。先不要慌，我们来看看oracle是怎么定义这些状态的：<br><strong>Reachability</strong><br>Going from strongest to weakest, the different levels of reachability reflect the life cycle of an object. They are operationally defined as follows:</p><ul><li>An object is <code>strongly reachable</code> if it can be reached by some thread without traversing any reference objects. A newly-created object is strongly reachable by the thread that created it.<br>An object is <code>softly reachable</code> if it is not strongly reachable but can be reached by traversing a soft reference.</li><li>An object is <code>weakly reachable</code> if it is neither strongly nor softly reachable but can be reached by traversing a weak reference. When the weak references to a weakly-reachable object are cleared, the object becomes eligible for finalization.</li><li>An object is <code>phantom reachable</code> if it is neither strongly, softly, nor weakly reachable, it has been finalized, and some phantom reference refers to it.</li><li>Finally, an object is <code>unreachable</code>, and therefore eligible for reclamation, when it is not reachable in any of the above ways.</li></ul><p>Since:<br>1.2<br>自然而然的<code>Since 1.2</code> ，看下文档再对比下Test，现在应该明朗多了吧。<br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ref/PhantomReference.html" target="_blank" rel="external">PhantomReference</a>：</p><p>Phantom reference objects, which are enqueued after the collector determines that their referents may otherwise be reclaimed. <code>Phantom references are most often used for scheduling pre-mortem cleanup actions in a more flexible way than is possible with the Java finalization mechanism.</code>If the garbage collector determines at a certain point in time that the referent of a phantom reference is <a href="">phantom reachable</a>, then at that time or at some later time it will enqueue the reference.<br>In order to ensure that a reclaimable object remains so, the referent of a phantom reference may not be retrieved: The get  method of a phantom reference always returns null.<br><code>Unlike soft and weak references, phantom references are not automatically cleared by the garbage collector as they are enqueued. An object that is reachable via phantom references will remain so until all such references are cleared or themselves become unreachable.</code></p><ul><li>一个对象仅如果持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</li><li>虚引用主要用来跟踪对象被垃圾回收器回收的活动。</li></ul>]]></content:encoded>
      
      <comments>https://harlber.github.io/2017/09/25/Java-Reference/#disqus_thread</comments>
    </item>
    
    <item>
      <title>图片列表页的优化策略</title>
      <link>https://harlber.github.io/2017/09/25/list-optimization/</link>
      <guid>https://harlber.github.io/2017/09/25/list-optimization/</guid>
      <pubDate>Mon, 25 Sep 2017 10:56:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;项目中经常会有一个用户头像上传的功能，与之匹配的是，有一个预览相册，裁剪相册的页面。在常规的解决方案中，当相册中图片数目庞大的时候，经常会造成页面性能问题（由于UI的关系不使用系统的裁剪功能，而是自己实现另一套，容易造成内存占用大，页面卡顿）&lt;br&gt;&lt;img src=&quot;ht
        
      
      </description>
      
      <content:encoded><![CDATA[<p>项目中经常会有一个用户头像上传的功能，与之匹配的是，有一个预览相册，裁剪相册的页面。在常规的解决方案中，当相册中图片数目庞大的时候，经常会造成页面性能问题（由于UI的关系不使用系统的裁剪功能，而是自己实现另一套，容易造成内存占用大，页面卡顿）<br><img src="http://upload-images.jianshu.io/upload_images/1740379-b66969bb1f388cb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优化前性能指示图.png"></p><p>如上图所示，该截图取自公司项目中图片预览页面时Monitors的实时图。其中内存有2次明显的上升（实际上内存占用从30M上升到了164.42M），而GPU monitor中则显示掉帧明显（从50s开始，远超16ms，期间夹杂掉帧）。</p><p>这样的性能对应用而言显然是不能接受的，因此我们要逐步将其性能优化到合理的范围。</p><p><strong>首先</strong>，考虑到列表页的图片并非详情页的高清大图，因此在展示的时候大可以对图片进行压缩。可采用如下代码将图片压缩至合理的范围，例如100K，120K。</p><pre><code>BitmapFactory.Options newOpts = new BitmapFactory.Options();newOpts.inJustDecodeBounds = true;newOpts.inPreferredConfig = Bitmap.Config.RGB_565;// Get bitmap info, but notice that bitmap is null nowBitmap bitmap = BitmapFactory.decodeFile(path, newOpts);newOpts.inJustDecodeBounds = false;int w = newOpts.outWidth;int h = newOpts.outHeight;float hh = 200;float ww = 200;int be = 1;if (w &gt; h &amp;&amp; w &gt; ww) {    be = (int) (newOpts.outWidth / hh);} else if (w &lt; h &amp;&amp; h &gt; hh) {be = (int) (newOpts.outHeight / ww);}if (be &lt;= 0) be = 1;newOpts.inSampleSize = be;bitmap = BitmapFactory.decodeFile(path, newOpts);</code></pre><p>经过压缩后，似乎能起到不错的效果。在此，我们来考虑另一个问题，列表页的图片经常会有页面滚动操作，因此，除了ListView/RecyclerView 本身的复用机制外，一个合理的解决方案是对图片也进行<strong>缓存（内存缓存）</strong>。在Adapter中我们可以这样修改（以RecyclerView为例）：</p><pre><code>public class PreviewImageAdapter extends RecyclerView.Adapter&lt;ImageVH&gt; {        private final int MAX_MEMORY_SIZE = 1024 * 20; //缓存大小        private LruCache&lt;String,Bitmap&gt; bitmapLruCache;        /*省略部分代码*/   @Override   public void onBindViewHolder(final ImageVH vh, final int i) {          if (bitmapLruCache.get(obj.getPath())!=null) {                 // display image          }else {                //load image , add to cache and display         }  }</code></pre><p>添加了<a href="">LruCache</a>后，接着思考另外的问题，这种做法提升了图片使用率，但还有一个问题没有解决，即不能抑制<strong>OOM的发生</strong>，在LruCache中的Bitmap都是强引用，存在OOM的风险。在此应该做进一步处理：</p><pre><code>public class PreviewImageAdapter extends RecyclerView.Adapter&lt;ImageVH&gt; {        private final int MAX_MEMORY_SIZE = 1024 * 20; //缓存大小        private LruCache&lt;String, SoftReference&lt;Bitmap&gt;&gt; bitmapLruCache;        /*省略部分代码*/   @Override   public void onBindViewHolder(final ImageVH vh, final int i) {          if (lruCache.get(obj.getPath()) != null &amp;&amp; lruCache.get(obj.getPath()).get() != null) {              SoftReference&lt;Bitmap&gt; bitmap = lruCache.get(obj.getPath());              if (bitmap != null) {                // display image                vh.sdv.setImageBitmap(bitmap.get());              } else {                  //load image and add to cache                  loadAndCacheBitmap(vh, obj.getPath());                      }          } else {                //load image and add to cache                loadAndCacheBitmap(vh, obj.getPath());         }  }</code></pre><p>软引用常用于实现高速缓存，在之前的<a href="http://www.jianshu.com/p/04b09d8a1745" target="_blank" rel="external">文章</a>中有提及。<br>做完了这些工作后，可以检验下成果了。如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-6e73ff5bd6411d7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优化后性能指示图.png"></p><p>可以看出，优化后，内存占用处于合理的范围内（最多增加申请的缓存大小的占用），同时GPU图显示绝大部分绘制能保持在16ms内。</p><p>至此，我们再思考下，还能继续把优化做下去吗？答案是肯定的，在此抛个砖。</p><ul><li>在加载/处理图片的时候，开了新线程进行处理，当有大量的图片操作时，线程的新建，销毁亦存在性能开销，较合理的方式是采用线程池进行管理。</li><li>以上的优化是在某个Adapter中进行的，而项目中有类似需求的不止一处</li></ul><p>至此，我们会惊奇的发现，绕了一圈，又回来了。是的，压缩，缓存图片（二级缓存/三级缓存），线程池进行调度，处理任务，这不就是ImageLoader具备的功能么？</p><ul><li><p>从GPU图中可以看出，还可以对绘制性能进行进一步优化</p></li><li><p>与列表联动，滑动时不进行任务操作（加载图片）</p></li><li>其他…</li></ul>]]></content:encoded>
      
      <comments>https://harlber.github.io/2017/09/25/list-optimization/#disqus_thread</comments>
    </item>
    
    <item>
      <title>日常开发技能指南（杂谈,持续更新）</title>
      <link>https://harlber.github.io/2017/09/25/android-kit/</link>
      <guid>https://harlber.github.io/2017/09/25/android-kit/</guid>
      <pubDate>Mon, 25 Sep 2017 10:55:19 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;保活&lt;/strong&gt;&lt;br&gt;先从老式最基础的开始：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用startService方式启动一个独立进程的服务，这样系统会在service意外死亡后自动重启。&lt;/li&gt;
&lt;li&gt;使用RTC定时闹钟每5分钟检测一下（4.0以上基本无效）
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>保活</strong><br>先从老式最基础的开始：</p><ul><li>使用startService方式启动一个独立进程的服务，这样系统会在service意外死亡后自动重启。</li><li>使用RTC定时闹钟每5分钟检测一下（4.0以上基本无效）</li><li>启动linux守护进程，每几分钟检测一下进程是否存在，不存在就startService（5.0以下除MIUI和华为外有效） </li><li>5.0以上使用JobScheduler代替闹钟定时检测启动 。</li><li>启动隐藏的前台通知。（支付宝即采用该方式，为系统的一个bug，在7.1.1中已修复，具体体现为下拉任务栏可以看到该通知。）<strong>但这些措施都不能100%保活。尤其是M中引入的doze模式，在doze模式中甚至无网络连接。</strong></li><li>官方建议：1.引导用户加入白名单；2.使用Google系列服务如GCM，Firebase</li></ul><p><strong>内存三级缓存思路</strong><br>对于列表页中的图片应使用LRU之类的内存缓存，对于activity和fragment销毁时应该把其对应的图片释放掉。每个图片都是有依赖引用的，我们一般默认是fragment或者是activity，当activity或者fragment销毁时，我们会将只依赖当前页面的图片移出LRU进行释放。</p><ul><li>内存图片缓存还是有三级：一级是bitmap列表，一级是LRU强引用，一级是弱引用。加载图片时，先在弱引用缓存和LRU强引用中查找没有被释放的bitmap，如果存在并满足复用条件，则不创建bitmap，而使用该图片内存，之后将其从弱引用或者LRU中移出放入bitmap列表强引用中。bitmap列表强引用保存了该图片依赖的直接控件。当view的onDetachedFromWindow被调用则从bitmap列表中移除只有依赖该view的对象到LRU强应用中。如果LRU强引用满了则放到弱引用中。</li><li>这种方案可以达到如下效果：列表滑动、或者打开新页面时会申请较小的内存或不申请内存。列表页来回滑动时依然有缓存可用。</li><li>对于adapterView和recycleView中的控件则需单独写个工具方法来封装一下。</li><li>这里实际上已经不需要弱引用了，只要从LRU中移除即可调用recycle方法释放该图片。</li><li>图片内存的申请和释放都由框架来控制，不由gc管理。</li><li>LRU的大小就是可调，它里面的图片内存是都可以释放的，它只是作为缓存而存在。</li></ul><p><strong>卡顿问题快速定位的方法<a href="">GPU monitor分析</a></strong>：</p><ul><li>打开开发者模式中GPU呈现模式分析，查看是那种颜色条高</li><li>如果是蓝色偏高，说明是单位消息里CPU太耗时，得把方法的执行都打出来看看哪个耗时。比如，在某处先看看是不是应该出现onMeasure，然后可以通过sdk自带的View布局工具，看一下哪个View的onMeasure耗时最多。</li><li>如果红色偏高，说明GPU忙不过来。优化过渡绘制，使用离屏缓存来优化。</li><li>黄色偏高，说明半透明GPU不仅在忙着绘制你的window也还忙着绘制别的，可能的情况为透明window叠加多了，window里的contentView有多个且相对复杂，或者GPU降频了等等，想具体分析需要查看GPU的trace。</li><li>画动画时蓝色偏高是不正常的</li></ul><p><strong>蓝色偏高的常见原因：</strong>1. 动画或者交互时缓存失效的太多，验证方法是打出方法trace看看是不是有很多次的invalidate调用和dispatchDraw耗时在前面。2. 触发了GC，验证看看trace中主线程是不是被莫名的暂停了。3. 触发了layout，这种蓝色会很高，trace中measure方法会耗时较高。</p><p><strong>如何优化启动速度</strong><br>没有闪屏页activity，一旦存在闪屏页activity那么启动速度就不大可能在200ms内跳过。<br>把window的背景设置为闪屏页，一旦MainActivity加载完毕就显示主页了。<br>虽然用户也会看到一个类似的闪屏页，但那个闪屏页实际只是activity在theme中设置的background。<br>之前好像有人问我怎么优化启动速度。这个方案适合启动画面不是作为广告页只是过渡页使用的场景。</p><pre><code>&lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash_logo&lt;/item&gt;</code></pre><p><strong>自定义高性能可拖动GridView</strong><br>在拖动过程中没有触发过invalidate，也没有触发requestLayout，别的应用每次移动动画会触发notifyDateChange，这会触发layout，影响性能。我们在拖动过程中会建立虚拟的视觉关系，只要不松手就会改变子view的顺序，只有松手才触发datechange。<br><strong>提升性能绘制方法</strong></p><ul><li>调用方法把它移出可见区域，移出可见区域后，在进行绘制的时候 native 层也不会去绘制它。</li></ul><p><strong>TextView优化</strong></p><ul><li>列表直接不用textview，自定义view，通过提前缓存 StaticLayout提升TextView性能，可参考：<a href="http://ragnraok.github.io/textview-pre-render-research.html" target="_blank" rel="external">http://ragnraok.github.io/textview-pre-render-research.html</a></li></ul><p><strong>Fragment留意点</strong><br>每个页面都是Fragment，自己管理其生命周期和栈，每次启动是以window的方式添加进来，进入动画为window动画，手势回退为View动画，为了节省内存，页面栈只保留2个对象，FragmentManager会进行回收释放和Fragment的恢复。</p><ul><li>优点：加载动画非常流畅，内存占用低，支持页面的无穷层级叠加。</li><li>缺点：以Window方式启动，很多系统的特性需要自己实现，难以驾驭。</li></ul><p><strong>状态栏兼容注意点</strong><br>针对状态栏我们单独适配了4.4以上版本，5.0以上版本，6.0以上版本，Flyme系统，6.0以上的Flyme系统，MIUI系统，6.0以上的MIUI系统，YunOS系统，VIVO Funtouch 2.5以下版本和2.5以上版本…….</p><p><strong>try-catch</strong></p><ul><li>如果你的代码一定会抛出异常，那try catch会有一些影响。</li><li>一旦捕获到异常，系统打到寄存器中获取当前函数调用栈，生成一堆信息，这总归是浪费性能的。</li><li>所以说一般不影响，非要扣那肯定影响，本来get方法可以进行内联的，用来try catch肯定就不能进行内联优化了，就会让性能下降一点。</li><li>android这几个版本推出了JIT，art虚拟机中重点对内联函数的范围进行扩充，try catch会阻止这些优化。</li><li>在android 5.0以上（ART进行OPT优化时）所有函数中存在try catch的方法都不能被JIT优化和进行内联优化</li></ul><p><strong>查看应用真实内存</strong></p><ul><li><p>adb shell dumpsys meminfo 你的包名 （monitor中不会显示WebView的内存占用）</p></li><li><p>（注意点）开了线程来执行耗时操作，可是这耗时操作执行的时候把主线的CPU占用给抢了。。。。</p></li></ul><p><strong>高绘制性能函数</strong><br>看一个ListView的函数</p><pre><code>offsetChildrenTopAndBottom(int index)</code></pre><p>这个方法性能很高，但是隐藏方法，listView移动子控件是用这个方法来移动的，它不破坏缓存，系统相当于是做了1+1+1+2，我们自己做就是1+2+1+2+1+2，我们自己写ListView的时候发现了这个函数，我们做for循环的性能还是不如系统的这个隐藏方法。</p><p><strong>使用windowManager的addView来添加控件</strong><br>例子：通过调用Fragment的onCreateView来生成一个View，然后addView进来，这导致跳转界面需要较长时间。现在得先addView一个View到windowManager中，然后在调用onCreateView，因为windowManager添加控件是在server进程，所以会立即addView进来，这时这里的View就需要显示点东西，这就需要类似windowBackground的东西来显示。windowBackground它存在的目的就是为了加快界面响应。</p><p><strong>实现自己的windowbackground</strong><br>先add一个类似decoreView进来，设置decoreView的background为windowBackground，然后在往这个decoreView上添加实际的控件。</p><p><strong>避免使用LayoutParams实现动画</strong></p><ul><li>setLayoutParams()会触发requestLayout()从而导致所有View重新measure、layout、draw，导致卡顿。<br>排查方法：可以用布局边界排查大小变化的。<br>例：爱范儿 下拉刷新。(排查方法为：重写顶端控件的requestLayout方法，打上断点，看看动画或者交互过程中谁调用到了这个方法)</li></ul><ul><li>还有查看谁刷新了页面导致重绘的排查方法是：重写顶端控件的invalidateChildInParent方法，看看谁调用到了。</li></ul><p><strong>使用硬件离屏缓存进行优化。（要保证缓存不失效）</strong></p><pre><code>正确的使用：显示硬件层更新绿色闪一下。错误的使用：过程中一直绿色。错误例：微信大图。正确例：掌阅首页切换</code></pre><ul><li>硬件加速本质上是属于window级别的东西，在创建ViewRootImpl的时候就确定了是否使用硬件加速，View级别所谓的关闭只是创建一张bitmap然后调用View的draw方法往这个上面绘制，绘制完成再往硬件加速的canvas上绘制。</li><li>系统对OpenGl方法进行了封装和优化，封装实现了canvas的方法，使用它有的时候比直接使用OpenGl性能还好。所以开硬件加速几乎等效于调用OpenGl接口来绘制，OpenGl是通用绘制接口，一般GPU都会实现这些接口，所以硬件加速是让GPU来绘制，而非硬件加速就是CPU自己绘制。</li><li>CPU要实现那么多的通用计算，而GPU就那么几个简单接口，它就极端优化，所以这几个简单方法的性能非常高。(OpenGl标准方法创建纹理很耗时，一张1080p的全屏图需要40ms以上，而android系统自己私有的方法10ms以内就创建完毕了)</li><li>Opengl创建纹理（texture）太耗时,后面使用比系统的速度快，系统被它那套递归绘制等拖累了性能。(opengl来实现ViewPager的效果，android2.2手机除了初始化创建交互的纹理，进行移动的时候8ms左右一帧。)</li></ul><p><strong>主动释放控件资源</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//释放布局资源</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseDradable</span><span class="params">(View view)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (view <span class="keyword">instanceof</span> ViewGroup) &#123;</div><div class="line">        <span class="keyword">int</span> count = ((ViewGroup)view).getChildCount();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++) &#123;</div><div class="line">             View childView = ((ViewGroup)view).getChildAt(i);</div><div class="line">             <span class="keyword">if</span> (childView <span class="keyword">instanceof</span> ViewGroup) &#123;</div><div class="line">                  releaseDradable(childView);</div><div class="line">               &#125;<span class="keyword">else</span> &#123;</div><div class="line">                releaseOneDrawable(childView);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">         &#125;<span class="keyword">else</span> &#123;</div><div class="line">            releaseOneDrawable(view);</div><div class="line">        &#125;</div><div class="line">  &#125;</div><div class="line"><span class="comment">//释放常见控件的资源,imageView是多种控件的根类</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseOneDrawable</span><span class="params">(View view)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (view !=<span class="keyword">null</span>) &#123;</div><div class="line">        BitmapDrawable src;</div><div class="line">        BitmapDrawable backGround;</div><div class="line">        <span class="keyword">if</span> (view <span class="keyword">instanceof</span> ImageView) &#123;</div><div class="line">            src = (BitmapDrawable) ((ImageView) view).getDrawable();</div><div class="line">            recycleBitmap(src.getBitmap());</div><div class="line">        &#125;</div><div class="line">        backGround = (BitmapDrawable) view.getBackground();</div><div class="line">        recycleBitmap(backGround.getBitmap());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">recycleBitmap</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span> &amp;&amp; !bitmap.isRecycled()) &#123;</div><div class="line">        bitmap.recycle();</div><div class="line">        bitmap = <span class="keyword">null</span>;    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上思路存在一个问题，即当某一个资源被多个activity引用时，回收该资源则会造成其他持有该资源的activity发生异常。</p><ul><li><p>维护一个Drawable链表用以记录引用次数</p></li><li><p>将控件的getDrawable()和getBackground()设置为null</p></li></ul><p><strong>系统Viewpager的性能优化</strong></p><ul><li>V4包里的SwipeRefreshLayout类在接收到down事件的时候，会调用bringToFront方法，该方法会触发requestLayout。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-81ad81690ca65f90.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SwipeRefreshLayout.jpg"></p><p><em>这里主要是优化ViewPager在添加和删除item的时候，会触发requestLayout导致的卡顿问题。第一次加载是没有优化的，因为必须得触发layout。</em><br>经过分析，我们的场景不需要这个方法，就去掉了该方法，<br>viewPager的adapter中instantiateItem()会执行container.addView(object)，这也会触发requestLayout；destroyItem也会触发requestLayout。可以替换为attachViewToParent和detachViewFromParent方法来进行add和remove。这俩方法是listView中进行动态add和remove的方法，性能很高，不会让缓存失效和触发requestLayout。</p><p>我们的ViewPager的setOffscreenPageLimit设置为1。调用detachViewFromParent方法后为了让ViewPager重新录制一下View的绘制，所以又手动调用了invalidate。<br><em>录制绘制就是dispatchDraw流程，不然会走getDisplayList流程</em></p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-b8a58f85d0a7f5dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="destroyItem.jpg"></p><p>在 instantateItem()中调用如下代码</p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-c20ff2716d394672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用代码.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-6b70a6d58944e733.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="instantateItem.jpg"></p><p><strong>微信db打开方式</strong><br>用户设备的IMEI+uin值计算MD5值，注意是小写字符，然后在取MD5的前7位字符构成的密码。</p><p><strong>关于RelativeLayout的使用</strong><br>大量使用了RelativeLayout，导致了多次mesure，一个relativelayout都要measure两次，多个层次这种叠加之后，measure次数指数级上升。</p><p><strong>关于 SoftwareRefrence</strong><br>在android低版本上，SoftwareRefrence是遵循java标准的GC回收流程，即只有触发GC的情况为内存不足时，才会去检查SoftReference，但在高版本上，SoftReference被检查的更频繁了，即不是只有内存不足时才去检查，其存在的概率与WeakReference接近。</p><p><strong>FragmentTabHost的问题</strong><br>每次FragmentTabHost切换fragment时会调用onCreateView()重绘UI。<br>解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> FragmentTransaction <span class="title">doTabChanged</span><span class="params">(String tabId,</span></span></div><div class="line"><span class="function"><span class="params">FragmentTransaction ft)</span> </span>&#123;</div><div class="line">TabInfo newTab = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mTabs.size(); i++) &#123;</div><div class="line">TabInfo tab = mTabs.get(i);</div><div class="line"><span class="keyword">if</span> (tab.tag.equals(tabId)) &#123;</div><div class="line">newTab = tab;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (newTab == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No tab known for tag "</span> + tabId);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (mLastTab != newTab) &#123;</div><div class="line"><span class="keyword">if</span> (ft == <span class="keyword">null</span>) &#123;</div><div class="line">ft = mFragmentManager.beginTransaction();</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (mLastTab != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">if</span> (mLastTab.fragment != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="comment">// 将detach替换为hide，隐藏Fragment</span></div><div class="line"><span class="comment">// ft.detach(mLastTab.fragment);</span></div><div class="line">ft.hide(mLastTab.fragment);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (newTab != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">if</span> (newTab.fragment == <span class="keyword">null</span>) &#123;</div><div class="line">newTab.fragment = Fragment.instantiate(mContext,</div><div class="line">newTab.clss.getName(), newTab.args);</div><div class="line">ft.add(mContainerId, newTab.fragment, newTab.tag);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">// 将attach替换为show，显示Fragment</span></div><div class="line"><span class="comment">// ft.attach(newTab.fragment);</span></div><div class="line">ft.show(newTab.fragment);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">mLastTab = newTab;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> ft;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>app启动优化</strong></p><ul><li><p>之前优化软件启动时间的时候，就是Application的attachBaseContext()开启method trace，首页的dispatchDraw方法被调用之后关闭，然后这段时间CPU都干了什么。</p></li><li><p>耗时的操作放到了dispatchDraw方法之后post一个回调来执行。</p><pre><code>Looper.getMainLooper().setMessageLogging(new Printer() {         @Override         public void println(String x) {             Log.e(&quot;msg&quot;, x);         }     });</code></pre></li></ul><p>用这个来测算每个消息花了多长时间，如果消息的执行时间超过了16ms，则获取当前的函数调用栈。<br>（可以确保你的耗时操作在页面显示之后才执行。）</p><ul><li>或者还有个onPostResume()方法，我们现在已经不用View的绘制之后再执行操作了，我们改为放到onPostResume方法中执行。（draw方法执行了，页面就显示了，然后不会黑屏或者白屏了）</li><li>app启动流程：Application的构造方法-&gt;attachBaseContext()-&gt;onCreate()-&gt;Activity的构造方法-&gt;onCreate()-&gt;配置主题中背景灯属性-&gt;onStart()…</li></ul><p><strong>关于inflate</strong></p><ul><li><p>inflate本身是io操作，而手机性能下降很大的一个原因就是io性能变差。</p></li><li><p>动态添加可以解决 xml 加载时间问题；自定义view 可以解决嵌套层级问题。</p></li></ul><p><strong>strings文件下多个同种类型字符串的问题</strong></p><ul><li><string name="part_inquiry_status_hit">共有%1$s条报价，已下%2$s单</string></li><li><string name="part_inquiry_status_hit" formatted="false">&lt;![CDATA[共有%s条报价，已下%s 单&gt;]]&gt;</string></li></ul><p><strong>RecyclerView的item的其他思路</strong></p><ul><li>recyleView中所有类型的item均为继承View，内容完全自己canvas绘制（一个个add进去），View中保存每个item的状态，获得该状态则可绘制出该View，bindView中无xml的inflate，已展示过的item再次显示时无需measure和耗时计算，ViewPager中limited item数为默认1，item被移除时，View内存被释放，再次进入时依靠保存的数据复原原item，此为同步操作。目前看来复原速度很快，用户对其是复原还是缓存的是感知不出来的。</li><li>android的新版本上也measure的结果进行了缓存，文本的测量也使用了100多K的空间进行全局缓存。</li></ul><p><strong>今日头条跟手回退实现–群分享记录</strong></p><ul><li><p>今日头条也是基于Activity的透明主题来实现的，但是这个方案都有两个缺点，一就是叠加层级一多，滑动性能会下降明显，基本叠加5层就很卡了，二是透明主题破坏了系统内存回收释放的策略，导致所有的activity都是前台Activity，系统都不会回收，就会OOM。解决这个问题有一个方案就是利用android 4.4里提供的动态设置Activity透明主题来实现，当叠加了三层之后就将底部的第三层改为非透明主题。</p><pre><code>   /**    * 动态将一个activity设置为不透明主题    *   * @param activity   */  public static void convertActivityFromTranslucent(Activity activity) {           try {                  Method method = Activity.class.getDeclaredMethod(&quot;convertFromTranslucent&quot;);                  method.setAccessible(true);                  method.invoke(activity);               } catch (Throwable t) {              }}</code></pre></li></ul><pre><code>      /** * 动态将一个activity设置为透明主题 * * @param activity */public static void convertActivityToTranslucent(Activity activity) {    try {        Class&lt;?&gt;[] classes = Activity.class.getDeclaredClasses();        Class&lt;?&gt; translucentConversionListenerClazz = null;        for (Class clazz : classes) {            if (clazz.getSimpleName().contains(                    &quot;TranslucentConversionListener&quot;)) {                translucentConversionListenerClazz = clazz;            }        }        if (Build.VERSION.SDK_INT &lt; 21) {//这个也仅支持4.4及以上            Method method = Activity.class.getDeclaredMethod(                    &quot;convertToTranslucent&quot;,                    translucentConversionListenerClazz);            method.setAccessible(true);            method.invoke(activity, new Object[]{null});        } else {//5.0以上的系统            Method method = Activity.class.getDeclaredMethod(                    &quot;convertToTranslucent&quot;,                    translucentConversionListenerClazz,                    ActivityOptions.class);            method.setAccessible(true);            method.invoke(activity, null, null);        }    } catch (Throwable t) {        t.printStackTrace();    }}</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1740379-7deea03712813199.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反编译某app.jpg"></p><ul><li><p>反编译了QQ空间的apk，他们把每个类的构造函数中添加了一行Zygote.class.getName()，Zygote是系统中存在的一个类。他们选用Zygote是android SDK中不存在的，被隐藏的类，他们应该是认为以后每个版本系统中都会有这个类，所以才选择了它。那么系统进行检查的时候就不会认为初始化该类只需要使用当前Dex。（<a href="">防止CLASS_ISPREVERIFIED </a>）</p></li><li><p>animation有个onAnimationStart和onAnmationEnd方法里面不可使用addView/removeView的方法，有可用handler.postRunable()来执行；开启硬件加速的时候有一些手机上会有概率性问题。硬件加速中draw流程只是进行录制，如果在录制的之后进行绘制的时候发现之前录制的已经无效了，在4.X的机型上就可能发生崩溃。动画的回调是在draw流程中执行的，在回调进行动态的removeView就会导致录制的绘制命令无效。</p></li><li>线程的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ArrayList &lt;File&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanDir</span><span class="params">(String dirString)</span></span>&#123;</div><div class="line">        File dirFile = <span class="keyword">new</span> File(dirString);</div><div class="line">        list.add(dirFile);</div><div class="line">        <span class="keyword">while</span> (list.size() &gt; <span class="number">0</span>)&#123;</div><div class="line">            File files[] = list.remove(<span class="number">0</span>).listFiles();</div><div class="line">            <span class="keyword">for</span>(File file : files)&#123;</div><div class="line">                <span class="keyword">if</span>(file.isDirectory())&#123;</div><div class="line">                    list.add(file);</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">if</span>(file.getAbsolutePath().endsWith(<span class="string">"mp3"</span>))&#123;</div><div class="line">                        Log.e(<span class="string">""</span>, <span class="string">"这是音乐文件"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>把递归变成队列，再把队列变成多线程执行，下面只需要开启多个线程来执行scanDir()，比如一共有n+1(CPU核心数+1)个线程来执行scanDir()，当list有第一个元素时开启一个线程执行scanDir()，这个线程会往list中继续添加元素，当开启的线程小于n+1时，继续开启线程，直到达到n+1，达到之后就等待线程执行完毕，其中某个线程执行完毕之后再次去list中获取底部的元素来执行scanDir，直到list大小为0。</p><ul><li>LayoutParams 的问题<br>直接new出来 View 如果不设置LayoutParams 就 add进一个viewgroup类型  它的LayoutParams 是由 父viewgroup generateDefaultLayoutParams函数 决定的。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-9cdc7a53d8ca49b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="view1.png"></p><ul><li>类型强转的注意点<br>强转前加 if xxx instanceof xx的校验，典型问题：<br>兼容包下的控件getContext不能强转为Activity(布局文件写入控件，activity继承AppCompatActivity )<br>追溯View第二个构造函数发现context是LayoutInfalte传来的，发现是LayoutInflater.from传来的，发是phoneWindow传来的 发现newPhoneWindow(Activity)  ，这样按理说view的context本身就是activity，可是报错说是 tintContextWrapper</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-33a9834ad2181bbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ImageView.png"></p><ul><li>activity在做动画的时候，页面的绘制是暂停的，或者只是绘制几帧。调用一个方法可以让其在动画过程中不暂停绘制。<br>反射调用<code>ViewRootImpl</code> 中的 <code>setDrawDuringWindowsAnimating(true)在</code>onAttachedToWindow后`调用(api 19及以上)类似的可以有：</li></ul><p><code>private boolean sInited = false;    private Method msetDrawDuringWindowsAnimatingMethod;    @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        super.onMeasure(widthMeasureSpec, heightMeasureSpec);        if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN_MR2 &amp;&amp; Build.VERSION.SDK_INT&lt; 24) {            Object viewRootImpl = ((Activity)getContext()).getWindow().getDecorView().getParent();            if (!sInited) {                try {                    msetDrawDuringWindowsAnimatingMethod = viewRootImpl.getClass().getMethod(&quot;setDrawDuringWindowsAnimating&quot;, boolean.class);                } catch (NoSuchMethodException e) {                    e.printStackTrace();                }                if (msetDrawDuringWindowsAnimatingMethod != null) {                    try {                        msetDrawDuringWindowsAnimatingMethod.invoke(viewRootImpl, true);                    } catch (IllegalAccessException e) {                        e.printStackTrace();                    } catch (InvocationTargetException e) {                        e.printStackTrace();                    }                }                sInited = true;            }        }    }</code></p><ul><li>优化View的inflate<br>如果你发现创建某个View的inflate很耗时，或者是measure和layout很耗时，你就只有采用类似这样的方式来优化它</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-9a3c26b48d3e6748.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="掌阅app代码.jpg"></p><p>耗时的工作完成的，把addViewInLayout之类的post到主线程就行了。<br>只有被添加到View树上的时候才可能会绘制，刚inflate出来的View没有被添加到View树上，所以不会进行measure和layout。measure是耗时的，如果在线程中执行，它就会减少主线程的卡顿，最后再添加到View树上，并且不用触发requestLayout。相当于<a href="">异步加载view</a><br>使用场景：比如进入一个页面开启网络加载一段内容，当网络数据回来了就刷新页面，如果这个页面是列表，那么如果是正在滑动的时候刷新页面就会卡顿，这时就可以使用这种方式来进行优化。</p><ul><li>利用aapt解析apk信息<blockquote><p>aapt dump badging demo.apk |grep version</p></blockquote></li></ul><p>aapt的其他参数，也比较使用，比如向apl中插入文件，删除文件，这个和unzip的效果是一样一样的。过去没用appt时，我们修改apk信息经常用zip/unzip，现在用appt也可以搞定，还能避免有的系统没有安装zip/unzip的问题</p><blockquote><p>aapt a demo.apk test.txt</p></blockquote><ul><li><p>Activity被销毁分为两种：1. Activity对象被从ActivityThread中移除了，这时只是把java对象置null，如果你其他地方还持有该对象，这个activity是不会被释放的。 2. Activity所在的进程被回收，那它所有的资源都被回收了。只会有一些可序列化的数据被保存。</p></li><li><p>以下条件webview可以关闭硬件加速</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-1d903c53b654aa35.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="关闭硬件加速.jpg"></p><pre><code>//mModelNumber = Build.MODEL;</code></pre><ul><li>获取GPU刷新帧率</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-2de0f7c3ab1403a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="GPU帧率.png"></p><p>可以利用Looper的log机制和添加全局控件来自己实现那个柱状图。</p><ul><li>列表优化思路<br>1.item中不能使用任何xml，包括xml的drawable；2.减少View个数层级降低过度绘制；3.自己实现TextView，系统的TextView（特别是android 7.0以下系统）性能太烂。</li></ul>]]></content:encoded>
      
      <comments>https://harlber.github.io/2017/09/25/android-kit/#disqus_thread</comments>
    </item>
    
    <item>
      <title>android项目优化（小结）</title>
      <link>https://harlber.github.io/2017/09/25/android-optimization/</link>
      <guid>https://harlber.github.io/2017/09/25/android-optimization/</guid>
      <pubDate>Mon, 25 Sep 2017 10:53:57 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;应用启动页&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;把window的背景设置为闪屏页（这里官方建议是140x140的logo），一旦MainActivity加载完毕就显示主页了。&lt;br&gt;虽然用户也会看到一个类似的闪屏页，但那个闪屏页实际只是acti
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>应用启动页</strong></p><ul><li><p>把window的背景设置为闪屏页（这里官方建议是140x140的logo），一旦MainActivity加载完毕就显示主页了。<br>虽然用户也会看到一个类似的闪屏页，但那个闪屏页实际只是activity在theme中设置的background。</p><pre><code>&lt;style name=&quot;Theme_MyApp&quot; parent=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot;&gt;    //Theme.Light.NoTitleBar.Fullscreen    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/preview&lt;/item&gt;    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;    &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;&lt;/style&gt;//...&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;   &lt;item android:drawable=&quot;@color/white&quot; /&gt;   &lt;item&gt;            &lt;bitmap                    android:src=&quot;@drawable/logo&quot; /&gt;   &lt;/item&gt;&lt;/layer-list&gt;//...public class MyMainActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {    // Make sure this is before calling super.onCreate         setTheme(R.style.Theme_MyApp);         super.onCreate(savedInstanceState);   // ...    }  }</code></pre></li><li><p>Application中的onCreate()中耗时io操作进行新开线程处理，组件的注册，初始化延时操作。</p></li><li>对于分包项目，加载dex的耗时是引起第一次进入应用白屏的主要原因，对于一些组件的初始化，类似的，创建Preference 耗时大约2ms，初始化Fresco 耗时大约 245ms，而加载dex耗时则可达10s左右。<br>对于插件化项目，建议新开线程提前加载dex。</li></ul><p><strong>主页/MainActivity</strong><br>优化主页性能的最重要的指标是页面创建时间，及ActivityManager的Displayed时间。可由以下几点进行优化：</p><ul><li>xml 加载是(实质上inflate本身属于io操作)，因此可优化布局层数（基于inflate算法）<br>以掌阅和bilibili的app为例子，通过uiautomatorviewer分析首页，可以看出掌阅的主页层次深度是9层，而bilibili主页则是18层（2017-3-9时候的最新版本），相应的页面展示时间为：</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-870f3c2961889660.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="掌阅主页.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-06dac05b8113fa01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bilibili主页.png"></p><ul><li>复杂的组合布局可直接通过自定义View的形式，以减少组件内部控件的measure，layout时间；同时也能减少布局层次。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-0b20a71ccf86a8fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bilibili的tablayout.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-e23be574fe00ef91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="掌阅的tablayout.png"></p><p><strong>绘制性能</strong></p><ul><li><p>检测activity的布局创建耗时<br>在Android Monitor的logcat中过滤查看ActivityManager条目，查看Displayed时间<br><img src="http://upload-images.jianshu.io/upload_images/1740379-6dabb976a91b26cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ActivityManager.png"></p></li><li><p>过度绘制检测（Overdraw）<br>在开发者模式中开启，对应用的每一个页面进行检测。<br>Overdraw有时候是因为你的UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。常见的是背景资源，根布局中设置了一遍，子布局中又进行多次设置。通常通过移除重复的背景资源，如移除Window的默认背景：</p><pre><code>this.getWindow().setBackgroundDrawable(null);</code></pre></li></ul><p>对于自定义View，则通过设置ClipRect（canvas.clipRect(…)）区域进行过度绘制优化</p><ul><li><a href="https://developer.android.com/studio/profile/am-gpu.html" target="_blank" rel="external">gpu monitor</a><br>在开发者模式中开启GPU呈现模式图，分析每一个页面的gpu运行状态（需考虑在低端手机上的表现）。<br><a href="">蓝色偏高</a>，说明是单位消息里CPU太耗时，得把方法的执行都打出来看看哪个耗时。比如，在某处先看看是不是应该出现onMeasure，然后可以通过sdk自带的View布局工具，看一下哪个View的onMeasure耗时最多。<br><a href="">红色偏高</a>，说明GPU忙不过来。优化过渡绘制，使用离屏缓存来优化。<br><a href="">黄色偏高</a>，说明半透明GPU不仅在忙着绘制你的window也还忙着绘制别的，可能的情况为透明window叠加多了，window里的contentView有多个且相对复杂，或者GPU降频了等等，想具体分析需要查看GPU的trace。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-a5d4304f2dc9071e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt=" Component bars 4.0 ~ 5.0.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-d30b31866d9469b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="Android 6.0 and higher.png"></p><ul><li>HierarchyViewer<br>可完整，详细体现出每一个布局的创建耗时，优化每一个‘红灯’。</li><li><p>布局复用，层级嵌套<br>结合HierarchyViewer分析，不多累赘。</p></li><li><p><a href="https://developer.android.com/studio/profile/am-methodtrace.html" target="_blank" rel="external">Method Tracer</a><br>在CPU monitor中点击计时器图标进行，将生成后的trace复制到 sdk/tools下（如test.trace）<br>在终端中执行</p><pre><code>traceview.bat test.trace</code></pre></li><li>自定义组件<br>部分复杂且可循环利用的ui需考虑写成自定义组件，手动实现onMeasure，onLayout同时亦可解决嵌套层级问题；此外可考虑动态添加控件以减少解决 xml 加载时间（inflate本身是io操作，而手机性能下降很大的一个原因就是io性能变差）。</li></ul><p><strong>内存管理</strong></p><ul><li>memory monitor<br>可在android studio中观测memory的变化（最准确的是使用adb dumpsys meminfo 来获取），在运行每一个页面的时候观测memory monitor中曲线变化，留意是否存在以下情形：<ul><li>高内存占用<br>普通页面布局不复杂，加载图片少，却占用大量内存，如100M以上。</li><li>内存抖动<br>大量对象频繁的创建，销毁能引起内存抖动。</li><li>gc回收不明显<br>如在简洁页面下，手动gc，回收内存较少，且内存占用大，应考虑内存泄露 。</li></ul></li><li>降低内存占用<br>a.在存在大量图片页面，尽可能采用软引用/弱引用对图片进行管理，降低对系统的负荷。<br>b.页面关闭时，主动进行释放资源（background置null等）。<br>c.Config常量文件拆分，按功能模块建立常量类，按需加载，减小常量池的大小（目前项目常量数，普遍在500个左右）。</li><li>内存泄露<br> 可参考之前的<a href="http://www.jianshu.com/p/56f008065246" target="_blank" rel="external">文章</a><ul><li>常见内存泄露场景<br>a.单例<br>尤其是部分带ui的单例，如dialog，因持有Context而发生泄露。<br>b.内部类<br>内部类（非静态内部类）的存在需依赖外部类实例（持有引用），常见的是Handler的泄露<br>c.观察者模式的反注册，常见的广播，各种事件总线<br>d.长连接，持续性<br>网络，流，数据库连接，动画的关闭。<br>e.native方法泄露<br>常见于bitmap的泄露，未对bitmap进行回收处理。</li></ul></li></ul><p>项目中重点检测各类Utils带Context/Activity参数的方法。</p><ul><li><p>资源兜底回收<br>复杂页面，抑或引用大量资源的页面，在关闭页面后，主动释放资源。</p></li><li><p>内存分析工具<br>a.MAT<br>b.Android studio自带memory monitor<br>c. <a href="https://github.com/square/leakcanary" target="_blank" rel="external">leakcanary</a><br>d.其他三方类库（github上的<a href="https://github.com/square/haha" target="_blank" rel="external">haha</a>等项目）</p></li></ul><p><strong>网络请求</strong><br>在已有的功能基础上增加请求合并的功能，常见的实现方式为，在同一个请求队列中，对相同的请求进行合并以减少网络请求次数。<br><strong>应用体积压缩（瘦身）</strong></p><ul><li><p><a href="">删选so库</a> 了解应用的设备分布范围，常见的如x86平台的可以忽略（即不支持）</p><pre><code> defaultConfig {         applicationId APPLICATION_ID         minSdkVersion MIN_SDK_VERSION as int         targetSdkVersion TARGET_SDK_VERSION as int         versionCode VERSION_CODE as int         versionName VERSION_NAME         multiDexEnabled MULTI_DEX_ENABLE as boolean         ndk {               abiFilters &apos;armeabi-v8a&apos;              //abiFilters &apos;x86&apos;, &apos;x86_64&apos;, &apos;armeabi&apos;,&apos;armeabi-v7a&apos;,&apos;armeabi-v8a&apos;       }}</code></pre></li><li><p><a href="">压缩资源</a><br>a.采用tinypng可将图片压缩至原图的20%-50%<br>b.Drawable xml替代图片：常见的纯色的背景，同时由于是直接将 Shape 信息传到底层由 GPU 进行渲染，有一定程度上性能提升。<br>c.只保存一份图片资源（慎重）<br>目前市面上大部分机型都处于 xxhdpi 的适配范围，因此可以考虑只保留 xxhdpi 目录下一份图片资源。<br>d.删减资源</p><pre><code> buildTypes { release {     minifyEnabled true     shrinkResources true     proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;  }}</code></pre><p>e.移除未使用的备用资源</p><pre><code>android {     defaultConfig {          ...          resConfigs &quot;en&quot;, &quot;fr&quot;    }}</code></pre><p>f.管理三方类库（因在建立项目之初即需考虑的问题）</p><ul><li>如项目中引入三方类库为解决某一个问题时（常见的是一些ui效果，在开发之初无充裕的时间成本），因此在优化阶段建议手动实现已减少依赖。</li><li>合并，精简类库<br>某些带有重复功能的类库，类似的volley与okhttp，glide的类库，存在功能上的重叠，建议删选。</li></ul></li></ul><p><strong>线程监测</strong><br>在Android Studio中打开Tools/Android/Android Device Monitor，在mmds中查看应用线程状况，尤其是网络请求线程数目，状态</p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-8d173b965899359a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="DDMS.png"></p><p><strong>低内存</strong><br>在OnTrimMemory中主动释放可回收资源，取消动画效果，减少/合并网络请求。<br><strong>AS自带工具使用</strong></p><ul><li><a href="http://tools.android.com/tips/lint" target="_blank" rel="external">lint</a> 检测整个项目，Win下可在Terminal中执行命令<pre><code>gradlew lint</code></pre>或选中lint项</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-6db84b3ccef1dc26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="lint.png"></p><p>根据文档建议修改（原则上消除每一个文件中的warning）.<br>也可以自定义规则检测项目代码规范。</p><ul><li>删除无用资源：<br>在Refactor中选择 Remove Unsed Resources…</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-f98a45088b7401fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Remove Unsed Resources....png"></p><p><strong>其他代码细节</strong></p><ul><li>枚举<br>如仅仅实现标识静态常量的功能，不建议使用枚举，直接采用接口更为便捷，合理；在要保证参数类型安全的情况下（编译时类型安全），完全可以使用，不用在意这么点内存占用。</li><li><p>View中的订阅与取消订阅<br>常见的如RxBus的使用，会在<strong><em>onCreate(Bundle savedInstanceState)</em></strong>中注册，在<strong><em>onDestroy()</em></strong>中取消注册，如：</p><pre><code> @Override protected void onCreate(Bundle savedInstanceState) {          super.onCreate(savedInstanceState);          setContentView(setLayout());          //注册事件         RxBus.getInstance().register(RxEvent.INQUIRY,this); }@Override public void onDestroy(){        //解绑注册       RxBus.getInstance().unregister(RxEvent.INQUIRY,this);       super.onDestroy(); }</code></pre><p>更为合理的方式则是以页面挂载/卸载为标准</p><pre><code>@Override protected void onAttachedToWindow() {          RxBus.getInstance().register(RxEvent.INQUIRY,this);     }@Override protected void onDetachedFromWindow() {         super.onDetachedFromWindow();         RxBus.getInstance().unregister(RxEvent.INQUIRY,this);    }</code></pre><p>参考：<a href="https://medium.com/square-corner-blog/android-leak-pattern-subscriptions-in-views-18f0860aa74c#.efkkxrsdy" target="_blank" rel="external">android-leak-pattern-subscriptions-in-views</a></p></li><li><p>引导用户添加进白名单</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-f65d3fcef932d4f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="startactivity.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-25ef2d48c73b6ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="whitelist.png"></p>]]></content:encoded>
      
      <comments>https://harlber.github.io/2017/09/25/android-optimization/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读书有感-《代码整洁之道》</title>
      <link>https://harlber.github.io/2017/09/25/read-clean-code/</link>
      <guid>https://harlber.github.io/2017/09/25/read-clean-code/</guid>
      <pubDate>Mon, 25 Sep 2017 10:49:32 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;读书应该是个好习惯，尤其是读到有感悟，灵感的时候，记录下来。&lt;br&gt;在读《代码整洁之道》之前，公司的项目已经有一套相对比较文档的&lt;code&gt;规范文档&lt;/code&gt;。但就这几个月接手同事的大作进行维护时，所得到的体验是痛苦的（期间甚至通过周末加班把某部分功能模块完全重写）。因
        
      
      </description>
      
      <content:encoded><![CDATA[<p>读书应该是个好习惯，尤其是读到有感悟，灵感的时候，记录下来。<br>在读《代码整洁之道》之前，公司的项目已经有一套相对比较文档的<code>规范文档</code>。但就这几个月接手同事的大作进行维护时，所得到的体验是痛苦的（期间甚至通过周末加班把某部分功能模块完全重写）。因此怀里揣着疑问阅读此书。</p><p><strong>为什么需要<code>代码整洁</code>？</strong><br>事实上，已经不止一次在项目中遇见某些可读性低，逻辑混淆，看起来很糟糕的，然而事实上却能很稳健运行的代码片段。对于这样的代码，我们要保持<code>原汁原味</code>，<code>敬而远之</code>（烧个高香）。除非去维护/扩展这部分代码片段，否则一眼也不想见到它！一旦接手了，我们又千方百计去祈祷：可以不好看，但逻辑不能乱…</p><p>这样的场景在已多次遇到，也正是书中所说的<code>初衷</code></p><ul><li>早期的编辑器回放功能显示：在写新代码的时候，我们一直在读旧代码，读与写花费的时间比例超过10：1，既然如此，我们就应让读的过程变得轻松（p10~p11）。某种程度来说，读的难度影响了写的难度（当然，从0开始的项目不存在读的过程）。</li></ul><p><strong>道可道，非常道，整洁之道到底是什么呢？</strong><br>想起一个表情，这里文字描述下：<br>A：你们渴望什么？<br>众人：XX<br>A：还有呢？<br>众人：更多的XX<br>A：还有吗？<br>众人：更大的XX</p><p>放在这里是简洁，简洁再简洁<br>比如说：</p><ul><li>变量命名：望名知其意，无双关语义，无歧义</li><li>方法命名：能准确描述方法的内容，布尔类型的用isXXX等等</li><li>参数规范：方法所含有的参数越少越好</li><li>方法体大小：却短越好</li><li>方法的职责：越少越好，最好只做一件事<br>等等</li></ul><p><strong>注释</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">“别给糟糕的代码加注释——重写吧”</div><div class="line">                     ——Brian W.Kernighan与P.J.Plaugher</div></pre></td></tr></table></figure><p>读代码相当一部分内容都是在读注释，一份合理的注释简直是你事半功倍的神器。当然在读此书前，个人的理解是注释越详细越好，谁说不是呢？真的这样么？</p><p>在某些情况下注释应当减少甚至没有</p><ul><li>某方法的方法名已经很明白显示了该方法所要做的事，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillJsonData</span><span class="params">(JsonObject json)</span></span>&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>直接明白表明<code>填充json中的数据</code></p><ul><li>注释中的作者，日期，修改日期<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">常见的是</div><div class="line">修改日期：<span class="number">2017</span>-<span class="number">08</span>-<span class="number">24</span> <span class="number">17</span>:<span class="number">44</span>:<span class="number">45</span></div><div class="line">修改版本：v1.0.2</div><div class="line">修改内容：xxx</div></pre></td></tr></table></figure></li></ul><p>这部分完全可以不写（svn/git仓库中不仅有，而且更详细）</p><p><strong>思维链</strong><br>阅读的顺序是<code>自上而下</code>的因此代码编写的思路最好顺应阅读的思路</p><ul><li>常量，变量写在类的头部/方法的头部</li><li>方法调用链聚合，如<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</div><div class="line">       xxx</div><div class="line">       methodB();</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</div><div class="line">       xxx</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li></ul><p>内部方法调用能紧密跟随，而不是天各一方.</p><ul><li>不要传递null值<br>当不确定调用某方法返回是否可能为null的时候，习惯的，我们会加判断，这样会带来一个问题：方法调用连上所有步骤都要判断，简而言之，NULL值满天飞。</li></ul><p>以上，这本书是为数不多可以一口气看完一大段而不带喘气的，目前仍有2章节未阅读，Junit和并发（<code>Java并发实战</code>没看完，这书好难~~）。</p>]]></content:encoded>
      
      <comments>https://harlber.github.io/2017/09/25/read-clean-code/#disqus_thread</comments>
    </item>
    
    <item>
      <title>逆向某fun</title>
      <link>https://harlber.github.io/2017/09/25/%E9%80%86%E5%90%91%E6%9F%90fun/</link>
      <guid>https://harlber.github.io/2017/09/25/%E9%80%86%E5%90%91%E6%9F%90fun/</guid>
      <pubDate>Mon, 25 Sep 2017 09:07:22 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在官网上下载最新版本（坑爹的是并不是最新版本）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用apktool反编译&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;apktool d [-s]  -f acfun_v4.4.1_portal.apk -o acfun&lt;/p&gt;
&lt;/blockqu
        
      
      </description>
      
      <content:encoded><![CDATA[<p>在官网上下载最新版本（坑爹的是并不是最新版本）</p><ul><li><p>用apktool反编译</p><blockquote><p>apktool d [-s]  -f acfun_v4.4.1_portal.apk -o acfun</p></blockquote></li><li><p>下载SmaliIDEA <a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="external">https://bitbucket.org/JesusFreke/smali/downloads/</a><br>将反编译后工程导入as，添加为source root。<br>接下来Run-&gt;Edit Configurations 添加Remote，稍等要修改端口。</p></li><li><p>重新用apktool打包安装进手机</p><blockquote><p>apktool b acfun -o acfun_unsigned.apk</p></blockquote></li></ul><p><a href="">遇到问题1：安装的时候报了个解析软件包出现问题</a></p><ul><li>使用auto-sign重新打包<blockquote><p>java -jar signapk.jar testkey.x509.pem testkey.pk8 acfun_unsigned.apk acfun_signed.apk</p></blockquote></li></ul><p>再次安装，安装成功，但显示了如下dialog</p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-61a7d442b5ea0352.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="sign.jpg"></p><ul><li>打开smali工程，进入res/strings.xml查找该提示语</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-3262b848971b4355.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="sign_string.png"></p><ul><li><p>在public.xml中查找该id资源</p><blockquote><public type="string" name="sign_check_content_text" id="0x7f080300"></public></blockquote></li><li><p>在smali中全局查找引用0x7f080300处</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-25069c894c7ccda8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/960" alt="jni.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-09eb21b4c3af6605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/960" alt="show.png"></p><ul><li>再看dismiss方法</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-296fca8b1eaee65d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/960" alt="kill_pid.png"></p><p>这就是为什么点击dialog应用会退出</p><ul><li><p>修改smali代码，将dismiss方法删除，重新打包安装，运行<br><a href="">遇到问题2：一直卡在Splash页面无法进入MainActivity</a></p></li><li><p>反编译dex文件，查看源码，经过刚才的smali文件中定位过的校验方法可知问题存在于SplashActivity，查看源码</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-252a35f07f878d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/960" alt="splash.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-32d362b9a342ec46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/960" alt="utils.png"></p><p>可以看出如果本地校验不通过，将一直循环调用setContontView，导致页面一直卡在SplashActivity，因此，光删除自杀代码还够，更应该修改校验逻辑</p><ul><li>强制设置校验通过<blockquote><p>在move-result V0 下面添加 const/4 v0, 0x1</p></blockquote></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1740379-0ba80f7ce7b1cd6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/960" alt="true.png"><br>再次打包运行，可以进入MainActivity了，but。。。</p><p><img src="http://upload-images.jianshu.io/upload_images/1740379-bcf4e291a8d7b0c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt="vision.png"><br>坑爹呀，官网下的居然不是最新版本…</p><ul><li>修改版本号重新打包，或者手动强制修改dialog逻辑。。。</li></ul><p>以上只做学术研究，请勿用于商业目的</p>]]></content:encoded>
      
      <comments>https://harlber.github.io/2017/09/25/%E9%80%86%E5%90%91%E6%9F%90fun/#disqus_thread</comments>
    </item>
    
    <item>
      <title>博客搬家了</title>
      <link>https://harlber.github.io/2017/09/25/hello_blog/</link>
      <guid>https://harlber.github.io/2017/09/25/hello_blog/</guid>
      <pubDate>Mon, 25 Sep 2017 07:58:41 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;原简书上的博客 &lt;a href=&quot;http://www.jianshu.com/u/9e472bc10163&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/u/9e472bc10163&lt;/a&gt; 现搬家到这里了。
        
      
      </description>
      
      <content:encoded><![CDATA[<p>原简书上的博客 <a href="http://www.jianshu.com/u/9e472bc10163" target="_blank" rel="external">http://www.jianshu.com/u/9e472bc10163</a> 现搬家到这里了。</p>]]></content:encoded>
      
      <comments>https://harlber.github.io/2017/09/25/hello_blog/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
